<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Decentralised Art Server</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: system-ui, sans-serif;
            background-color: #0d0d0d;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            margin: 0;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        h2 {
            font-size: 1.5rem;
            margin-top: 2rem;
        }

        label,
        input,
        button {
            display: block;
            width: 100%;
            margin-bottom: 1rem;
        }

        .button-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .button-row button {
            flex: 1;
            min-width: 120px;
        }

        textarea {
            display: block;
            width: 100%;
            height: 150px;
            font-family: monospace;
            background-color: #1e1e1e;
            color: #ffffff;
            border: 1px solid #444;
            border-radius: 4px;
        }

        input {
            background-color: #1e1e1e;
            color: #ffffff;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 0.5rem;
        }

        button {
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 0.8rem;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
        }

        button:hover {
            background-color: #0f66c0;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            max-width: 1000px;
            width: 100%;
        }

        .column {
            flex: 1;
            min-width: 300px;
        }

        .response-row {
            display: flex;
            gap: 1rem;
        }

        .response-code {
            flex: 1;
            background: #333;
            color: #fff;
            padding: 0.5rem;
            border-radius: 6px;
            text-align: center;
            max-width: 100px;
        }

        .response-body {
            flex: 3;
            background: #333;
            color: #fff;
            padding: 0.5rem;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
        }

        .request-row {
            display: flex;
            gap: 2rem;
            margin: 1rem;
        }

        .request-body {
            flex: 3;
            background: #333;
            color: #fff;
            padding: 0.5rem;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
        }

        hr {
            width: 100%;
            border: 1px solid #333;
            margin: 2rem 0;
        }

        #treeContainer {
            overflow: visible; /* critical */
            position: relative;
            z-index: 0; /* baseline */
        }

        .vis-tooltip {
            position: absolute !important;
            z-index: 9999 !important;
            background: #333;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            white-space: nowrap;
            max-width: 300px;
        }
        #popupInstanceEditor, 
        #popupInstanceEditor * {
            box-sizing: border-box;
        }
    </style>

    <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
    <link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />

    <script src="https://cdn.jsdelivr.net/npm/jzz"></script>
    <script src="https://cdn.jsdelivr.net/npm/jzz-midi-smf"></script>
</head>

<body>
    <div style="margin-top: 4rem; color: #888; font-size: 0.9rem; text-align: center;">
        <div id="versionInfo">Loading version info...</div>
    </div>
    <h1>Decentralised Art Server</h1>
    <p style="text-align:center; max-width:600px">Interact with the API endpoints directly from your browser.</p>

    <div class="row">
        <div class="column">
            <button id="login" class="response-body">Login with MetaMask</button>
            <div class="response-row">
                <div id="loginStatus" class="response-body"></div>
            </div>
        </div>
    </div>

    <hr>

    <div class="row">
        <div class="column">
            <h2>Execute</h2>
            <div class="row" style="display: flex; gap: 1rem; align-items: flex-end;">
                <div style="flex: 1; min-width: 120px; margin-right: 1rem;">
                    <label>Feature name</label>
                    <input id="executeName" type="text" placeholder="pitch">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="visibility:hidden;">Fetch</label>
                    <button onclick="fetchBeforeExecute()">Fetch</button>
                </div>
            </div>
            <div id="popupInstanceEditor" style="display:none; position:fixed; top:20%; left:50%; transform:translateX(-50%); background:#222; color:#fff; padding:1rem; border-radius:8px; z-index:9999;">
                <h3>Edit Running Instance</h3>
                <p id="popupFeatureLabel"></p>
                <label>Start Point</label>
                <input type="number" id="popupStartPoint" style="width:100%;">
                <label>Transform Shift</label>
                <input type="number" id="popupTransformShift" style="width:100%;">
                <div style="margin-top:1rem; display:flex; justify-content: space-between;">
                    <button onclick="saveInstanceEdit()">Save</button>
                    <button onclick="closePopup()">Cancel</button>
                </div>
            </div>
            <label>Running Instances</label>
            <div class="request-row">
                <div id="executeRunningInstances" class="request-body"></div>
            </div>
            <div class="request-row">
                <div id="treeContainer" style="display: none; width: 100%; height: 400px; background: #1e1e1e; border-radius: 6px; margin: 1rem;"></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <div class="row" style="display: flex; gap: 1rem; align-items: flex-end;">
                <div style="flex: 1; min-width: 120px; margin-right: 1rem;">
                    <label>Sample count</label>
                    <input id="executeN" type="text" placeholder="5">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="visibility:hidden;">Execute</label>
                    <button onclick="execute()">Execute</button>
                </div>
            </div>
            <div class="response-row">
                <div id="executeCode" class="response-code">-</div>
                <div id="executeBody" class="response-body">Waiting...</div>
            </div>
        </div>
        <div class="column">
            <h2>MIDI Export</h2>
            <button onclick="buildMIDIMappingUI()">Map MIDI Channels</button>
            <div id="midiMapper"></div>
            <button onclick="visualizeStructuredMIDI()">üéπ Visualize MIDI</button>
            <div id="midiCanvasWrapper" style="display: none; width: 100%;">
                <div style="display: flex; justify-content: flex-end;">
                  <button onclick="hideMidiCanvas()" style="
                    background: #444;
                    color: #fff;
                    border: none;
                    border-radius: 4px;
                    padding: 4px 10px;
                    margin-bottom: 0.5rem;
                    cursor: pointer;
                  ">‚úñ Hide</button>
                </div>
                <canvas id="midiCanvas" style="width: 100%; height: 400px; border: 1px solid #555; background: #111;"></canvas>
              </div>
            <div class="row" style="display: flex; gap: 1rem; align-items: flex-end;">
                <div style="flex: 1; min-width: 120px; margin-right: 1rem;">
                    <label for="bpmInput">Tempo (BPM)</label>
                    <input type="number" id="bpmInput" placeholder="e.g. 120" min="20" max="300" value="120">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="visibility:hidden;">Export</label>
                    <button onclick="exportStructuredMIDI()">üéº Export</button>
                </div>
            </div>
        </div>
    </div>
    <hr>

    <div class="row">
        <div class="column">
            <h2>Send Feature</h2>
            <label>Feature Name</label>
            <input type="text" id="POST_featureName" placeholder="melody" oninput="updateFeatureRequestPreview()">
            
            <div id="dimensionsContainer"></div>

            <div class="button-row">
                <button onclick="addDimension()">‚ûï Add dimension</button>
                <button onclick="clearDimensions()">üóëÔ∏è Clear dimensions</button>
            </div>

            <label>Request body</label>
            <div class="request-row">
                <div id="POST_featureRequestBody" class="request-body"></div>
            </div>
            <button onclick="sendStructuredFeature()">Send</button>

            <div class="response-row">
                <div id="POST_featureResponseCode" class="response-code">-</div>
                <div id="POST_featureResponseBody" class="response-body">Waiting...</div>
            </div>
        </div>
        <div class="column">
            <h2>Fetch Feature</h2>
            <label>Name</label>
            <input id="GET_featureName" type="text" placeholder="pitch">
            <label>Address (optional)</label>
            <input id="GET_featureAddress" type="text" placeholder="0x0...">
            <button onclick="getFeature()">Fetch</button>
            <div class="response-row">
                <div id="GET_featureResponseCode" class="response-code">-</div>
                <div id="GET_featureResponseBody" class="response-body">Waiting...</div>
            </div>
        </div>
    </div>

    <hr>

    <div class="row">
        <div class="column">
            <h2>Send Transformation</h2>
            <label>Transformation Name</label>
            <input type="text" id="POST_transformationName" placeholder="add" oninput="updateTransformationPreview()">

            <div class="column">
                <label>Solidity Code</label>
                <div class="request-body">function run(uint32 x, uint32 [] calldata args) view external returns (uint32){</div>
                <textarea id="POST_transformationCode" placeholder="return x + args[0];" oninput="updateTransformationPreview()"></textarea>
                <div class="request-body">}</div>
            </div>

            <label style="margin:1rem;" >Request body</label>
            <div class="request-row">
                <div id="POST_transformationRequestBody" class="request-body"></div>
            </div>
            
            <button onclick="sendStructuredTransformation()">Send</button>
            
            <div class="response-row">
                <div id="POST_transformationResponseCode" class="response-code">-</div>
                <div id="POST_transformationResponseBody" class="response-body">Waiting...</div>
            </div>
        </div>
        <div class="column">
            <h2>Fetch Transformation</h2>
            <label>Name</label>
            <input id="GET_transformationName" type="text" placeholder="add">
            <label>Address (optional)</label>
            <input id="GET_transformationAddress" type="text" placeholder="0x0...">
            <button onclick="getTransformation()">Fetch</button>
            <div class="response-row">
                <div id="GET_transformationResponseCode" class="response-code">-</div>
                <div id="GET_transformationResponseBody" class="response-body">Waiting...</div>
            </div>
        </div>
    </div>
    <script>
        // --------------------------------------------------------------------------
        // MIDI
        // --------------------------------------------------------------------------
        function buildMIDIMappingUI() {
            const text = document.getElementById("executeBody").textContent;
            let parsed;
            try {
                parsed = JSON.parse(text);
            } catch (e) {
                alert("Invalid JSON output");
                return;
            }
        
            const container = document.getElementById("midiMapper");
            container.innerHTML = '';
        
            parsed.forEach((item, idx) => {
                const row = document.createElement('div');
                row.style.marginBottom = '1rem';
                row.innerHTML = `
                <fieldset style="border:1px solid #555; padding:0.5rem; margin-bottom:0.5rem; font-size: 0.9rem;">
                     <legend style="font-size: 0.9rem;">${item.feature_path}</legend>

                     <label style="display:flex; flex-wrap: wrap;  margin-bottom: 0.3rem;">Channel:
                         <input type="number" min="0" max="15" value="0" id="channelInput${idx}" style="width: 3rem; margin-left: 0.5rem;">
                     </label>

                    <div style="
                      display: grid;
                      grid-template-columns: auto auto;
                      gap: 0.4rem 1rem;
                      align-items: center;
                    ">
                      <label style="display: flex; align-items: center; gap: 0.4rem; min-width: 100px;">
                        <input type="checkbox" class="roleCheck" data-role="pitch" data-idx='${idx}' style="width:30%"> Pitch
                      </label>
                      <label style="display: flex; align-items: center; gap: 0.4rem; min-width: 100px;">
                        <input type="checkbox" class="roleCheck" data-role="time" data-idx='${idx}' style="width:30%"> Time
                      </label>
                      <label style="display: flex; align-items: center; gap: 0.4rem; min-width: 100px;">
                        <input type="checkbox" class="roleCheck" data-role="velocity" data-idx='${idx}' style="width:30%"> Velocity
                      </label>
                      <label style="display: flex; align-items: center; gap: 0.4rem; min-width: 100px;">
                        <input type="checkbox" class="roleCheck" data-role="duration" data-idx='${idx}' style="width:30%"> Duration
                      </label>
                    </div>
                
                </fieldset>
                `;
                container.appendChild(row);
            });
        }

        function collectChannelRoles(parsed) {
            const map = new Map();
                
            parsed.forEach((entry, i) => {
                const channel = parseInt(document.getElementById(`channelInput${i}`).value);
                if (isNaN(channel) || channel < 0 || channel > 15) return;
            
                const roleChecks = document.querySelectorAll(`.roleCheck[data-idx="${i}"]`);
                roleChecks.forEach(c => {
                    if (!c.checked) return;
                    const role = c.dataset.role;
                
                    if (!map.has(channel)) map.set(channel, { pitch: [], time: [], velocity: [], duration: [] });
                    const r = map.get(channel);
                    if (role === "pitch") r.pitch.push(entry.data);
                    else if (role === "time") r.time = entry.data;
                    else if (role === "velocity") r.velocity = entry.data;
                    else if (role === "duration") r.duration = entry.data;
                });
            });
        
            return map;
        }
        
        function hideMidiCanvas() {
            document.getElementById("midiCanvasWrapper").style.display = "none";
        }
        
        function visualizeStructuredMIDI() 
        {
            document.getElementById("midiCanvasWrapper").style.display = "block";

            const text = document.getElementById("executeBody").textContent;
            let parsed;
            try {
                parsed = JSON.parse(text);
            } catch (e) {
                alert("Invalid JSON output");
                return;
            }
        
            const ticksPerBeat = 480;
            const canvas = document.getElementById("midiCanvas");
            const ctx = canvas.getContext("2d");
            // Set internal resolution to match displayed size
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            const colors = [
                "#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4",
                "#46f0f0", "#f032e6", "#bcf60c", "#fabebe", "#008080", "#e6beff",
                "#9a6324", "#fffac8", "#800000", "#aaffc3"
            ];
        
            const channelMap = collectChannelRoles(parsed);
        
            const defaultVelocity = 0;
            const defaultDuration = 0;
        
            const events = [];
        
            for (const [channel, { pitch, time, velocity, duration }] of channelMap.entries()) {
                if (!pitch.length) continue;
                const n = Math.max(...pitch.map(p => p.length));
            
                for (let i = 0; i < n; i++) {
                    const startBeat = (time?.[i] ?? 0);
                    const startTick = startBeat * ticksPerBeat;
                    const vel = Math.max(0, Math.min(127, velocity?.[i] ?? defaultVelocity));
                    const dur = duration?.[i] ?? defaultDuration;
                    const endTick = startTick + dur * ticksPerBeat;
                
                    for (const pitchArray of pitch) {
                        const note = (pitchArray[i] ?? 0);
                        events.push({
                            channel,
                            note,
                            start: startTick,
                            end: endTick,
                            velocity: vel
                        });
                    }
                }
            }
        
            // Normalize time and pitch for drawing
            const maxTick = Math.max(...events.map(e => e.end));
            const minNote = Math.min(...events.map(e => e.note));
            const maxNote = Math.max(...events.map(e => e.note));
        
            const margin = 10;
            const xScale = (canvas.width - 2 * margin) / maxTick;
            const yScale = (canvas.height - 2 * margin) / (maxNote - minNote + 1);
        
            // Draw pitch grid
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 0.5;
            for (let p = minNote; p <= maxNote; p++) {
                const y = canvas.height - margin - (p - minNote + 1) * yScale;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        
            // Draw time grid every beat
            ctx.strokeStyle = "#444";
            for (let b = 0; b < maxTick / ticksPerBeat; b++) {
                const x = margin + b * ticksPerBeat * xScale;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        
            const labelsMargin = 10; // for axis labels
        
            // Draw (Y-axis) labels
            const uniquePitches = [...new Set(events.map(e => e.note))].sort((a, b) => a - b);
            ctx.fillStyle = "#888";
            ctx.font = "12px monospace";
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            uniquePitches.forEach(p => {
              const y = canvas.height - labelsMargin - (p - minNote + 1) * yScale + yScale / 2;
              ctx.fillText(p.toString(), labelsMargin + 4, y);
            });

            // Draw (X-axis) labels
            const uniqueBeats = [...new Set(events.map(e => Math.floor(e.start / ticksPerBeat)))].sort((a, b) => a - b);
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            uniqueBeats.forEach(b => {
              const x = margin + b * ticksPerBeat * xScale;
              ctx.fillText(b.toString(), x, canvas.height - labelsMargin - 2);
            });
        
            events.forEach(evt => {
                const x = margin + evt.start * xScale;
                const y = canvas.height - margin - (evt.note - minNote + 1) * yScale;
                const width = (evt.end - evt.start) * xScale;
                const height = yScale - 1;

                // Normalize velocity to alpha [0.2‚Äì1] for visibility
                const alpha = Math.max(0.2, Math.min(1, evt.velocity / 127));
                const baseColor = colors[evt.channel % colors.length];
                ctx.fillStyle = hexToRgba(baseColor, alpha);
                ctx.fillRect(x, y, width, height);

                // Draw velocity number
                ctx.fillStyle = "#fff";
                ctx.font = "10px monospace";
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.fillText(evt.velocity.toString(), x + width / 2, y + (height / 2));
            });
        }


        function exportStructuredMIDI() {
            const text = document.getElementById("executeBody").textContent;
            let parsed;
            try {
                parsed = JSON.parse(text);
            } catch (e) {
                alert("Invalid JSON output");
                return;
            }
        
            const bpm = parseInt(document.getElementById("bpmInput").value);
            const tempo = isNaN(bpm) ? 120 : bpm;
            const ticksPerBeat = 480;
            const smf = new JZZ.MIDI.SMF(1, ticksPerBeat);
            const track = new JZZ.MIDI.SMF.MTrk();
            smf.push(track);
            track.smfBPM(tempo);
        
            const channelMap = collectChannelRoles(parsed);
        
            const defaultVelocity = 100;
            const defaultDuration = 1;
        
            for (const [channel, { pitch, time, velocity, duration }] of channelMap.entries()) {
                if (!pitch.length) continue;
            
                const n = Math.max(...pitch.map(p => p.length));
            
                for (let i = 0; i < n; i++) {
                    const beat = time?.[i] ?? i;
                    const tick = Math.floor(beat * ticksPerBeat);
                    const vel = Math.max(0, Math.min(127, velocity?.[i] ?? defaultVelocity));
                    const dur = duration?.[i] ?? defaultDuration;
                    const endTick = tick + Math.floor(dur * ticksPerBeat);
                
                    for (const pitchArray of pitch) {
                        const note = 60 + (pitchArray[i] ?? 0); // transpose base note to middle C
                    
                        track.add(tick, JZZ.MIDI.noteOn(channel, note, vel));
                        track.add(endTick, JZZ.MIDI.noteOff(channel, note, vel));
                    }
                }
            }
        
            // Generate binary and trigger download
            const blob = new Blob([smf.dump()], { type: "audio/midi" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "out.mid";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --------------------------------------------------------------------------
        // Running Instances
        // --------------------------------------------------------------------------
        let runningInstanceData = []; // indexed by node.id
        let currentNodeEditing = null;

        function openRIPopup(nodeId, label) {
            currentNodeEditing = nodeId;
            document.getElementById("popupFeatureLabel").textContent = label;
            const existing = runningInstanceData[nodeId] || [0, 0];
            document.getElementById("popupStartPoint").value = existing[0];
            document.getElementById("popupTransformShift").value = existing[1];
            document.getElementById("popupInstanceEditor").style.display = 'block';
        }

        function closePopup() {
            document.getElementById("popupInstanceEditor").style.display = 'none';
            currentNodeEditing = null;
        }

        function saveInstanceEdit() {
            const a = parseInt(document.getElementById("popupStartPoint").value);
            const b = parseInt(document.getElementById("popupTransformShift").value);
            if (!isNaN(a) && !isNaN(b)) {
                runningInstanceData[currentNodeEditing] = [a, b];
                updateRunningInstanceList();
            }
            closePopup();
        }
        
        function updateRunningInstanceList() {
            const result = runningInstanceData
                .map((v, i) => v ? `(${v[0]};${v[1]})` : null)
                .filter(v => v !== null);

            document.getElementById('executeRunningInstances').textContent = result.length > 0
                ? `[${result.join(',')}]`
                : '';
        }

        function clearRunningInstances() {
            runningInstanceData = [];
            updateRunningInstanceList();
        }

        // --------------------------------------------------------------------------
        // Execute
        // --------------------------------------------------------------------------
        function drawFeatureTree(treeData) {
            const nodes = [];
            const edges = [];
        
            treeData.forEach((item, index) => {
                nodes.push({
                    id: item.id,
                    label: item.name.split('/').pop(),
                    title: `${item.name}\n${item.scalar ? 'Scalar' : 'Composite'}`,
                    color: item.scalar ? '#1e90ff' : '#ffffff',
                    font: { color: item.scalar ? '#fff' : '#000' },
                    shape: item.scalar ? 'ellipse' : 'box' 
                });
            
                if (item.parent !== -1) {
                    edges.push({ from: item.parent, to: item.id });    
                }
            });
        
            const container = document.getElementById('treeContainer');
            const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
            const options = {
                layout: { hierarchical: { direction: 'UD', sortMethod: 'directed' } },
                physics: false,
                edges: { color: '#aaa' },
                interaction: { hover: true }
            };
        
            const network = new vis.Network(container, data, options);

            network.on("click", function (params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const nodeData = treeData.find(n => n.id === nodeId);
                    if (nodeData) {
                        openRIPopup(nodeId, nodeData.name);
                    }
                }
            });

            document.getElementById('treeContainer').style.display = 'block';
            network.fit();
        }

        async function fetchFeatureDepthFirst(rootFeatureName) 
        {
            clearRunningInstances();

            let nodeIdCounter = 0;
            const compositeList = [];
            const apiBase = window.location.origin;
            const stack = [{
                parent: -1,
                path: '',
                name: rootFeatureName,
                assignId: () => nodeIdCounter++
            }];

            while (stack.length > 0) {
                const { parent, path, name, assignId } = stack.pop();
                const id = assignId();
            
                try {
                    const res = await fetch(`${apiBase}/feature/${name}`);
                    if (!res.ok) throw new Error(`Failed to fetch ${name}`);
                    const feature = await res.json();
                
                    const fullPath = `${path}/${feature.name}`;
                    const scalar = feature.dimensions.length === 0;
                
                    compositeList.push({ parent, id, name: fullPath, scalar });
                    runningInstanceData[id] = [0, 0];
                
                    // Push children in reverse so they‚Äôre visited left-to-right
                    for (let i = feature.dimensions.length - 1; i >= 0; i--) {
                        const dim = feature.dimensions[i];
                        stack.push({
                            parent: id,
                            path: fullPath,
                            name: dim.feature_name,
                            assignId: () => nodeIdCounter++
                        });
                    }
                } catch (e) {
                    console.error(`Error fetching ${name}:`, e);
                }
            }

            updateRunningInstanceList();
            return compositeList;
        }
        

        async function fetchBeforeExecute() {
            const rootName = document.getElementById('executeName').value.trim();
            if (!rootName) {
                alert("Please provide a feature name.");
                return;
            }
                    
            const features = await fetchFeatureDepthFirst(rootName);

            drawFeatureTree(features);
        }

        async function execute() {
            const name = document.getElementById('executeName').value.trim();
            const N = document.getElementById('executeN').value.trim();
            const runningInstances = document.getElementById('executeRunningInstances').textContent.trim();

            const codeDiv = document.getElementById('executeCode');
            const bodyDiv = document.getElementById('executeBody');
            if (!name) {
                alert("Contract name is required.");
                return;
            }
            const apiBase = window.location.origin;
            const url = runningInstances === '' ? `${apiBase}/execute/${name}/${N}` : `${apiBase}/execute/${name}/${N}/${runningInstances}`;
            try {
                const res = await requestWithRefresh(url,
                {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include'
                }
                );
                const text = await res.text();
                codeDiv.textContent = res.status;
                bodyDiv.textContent = formatJSON(text);
            } catch (error) {
                codeDiv.textContent = 'Error';
                bodyDiv.textContent = error.message;
            }
        }

        // --------------------------------------------------------------------------
        // Feature
        // --------------------------------------------------------------------------
        async function updateFeatureRequestPreview() {
            const json = await constructStructuredFeature();
            document.getElementById('POST_featureRequestBody').textContent = json;
        }

        function clearDimensions() {
            const container = document.getElementById('dimensionsContainer');
            container.innerHTML = '';
            updateFeatureRequestPreview();
        }

        function addDimension() {
            const container = document.getElementById('dimensionsContainer');
            const index = container.children.length;
            const dim = document.createElement('div');
            dim.className = 'dimension';
            dim.innerHTML = `
                <fieldset style="border:1px solid #555;padding:1rem;margin-bottom:1rem;">
                    <legend>Dimension ${index + 1}</legend>
                    <label>Feature Name</label>
                    <input type="text" class="dimension-feature-name" placeholder="pitch" oninput="updateFeatureRequestPreview()">
                
                    <div class="transformations"></div>
                    <button type="button" onclick="addTransformation(this)">‚ûï Add transformation</button>
                </fieldset>
            `;
            container.appendChild(dim);
            updateFeatureRequestPreview();
        }

        function addTransformation(button) {
            const container = button.previousElementSibling;
            const t = document.createElement('div');
            t.innerHTML = `
                <hr>
                <label>Transformation name</label>
                <input type="text" class="transformation-name" placeholder="add" oninput="updateFeatureRequestPreview()">
                <label>args (comma-separated)</label>
                <input type="text" class="transformation-args" placeholder="..." oninput="updateFeatureRequestPreview()">
            `;
            container.appendChild(t);
            updateFeatureRequestPreview();
        }

        async function constructStructuredFeature()
        {
            const name = document.getElementById('POST_featureName').value.trim();
            const dimensions = [];
        
            document.querySelectorAll('.dimension').forEach(dimEl => {
                const feature_name = dimEl.querySelector('.dimension-feature-name').value.trim();
                const transformations = [];
                dimEl.querySelectorAll('.transformations > div').forEach(tEl => {
                    const tname = tEl.querySelector('.transformation-name').value.trim();
                    const targs = tEl.querySelector('.transformation-args').value.trim().split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
                    if (tname) {
                        transformations.push({ name: tname, args: targs });
                    }
                });
                if (feature_name) {
                    dimensions.push({ feature_name, transformations });
                }
            });
        
            return JSON.stringify({ name, dimensions }, null, 2);
        }

        async function sendStructuredFeature() {
            const requestBody = await constructStructuredFeature();
        
            const responseCodeDiv = document.getElementById('POST_featureResponseCode');
            const responseBodyDiv = document.getElementById('POST_featureResponseBody');

            try {
                const apiBase = window.location.origin;
                const res = await requestWithRefresh(`${apiBase}/feature`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: requestBody,
                    credentials: 'include',
                });
                const text = await res.text();
                responseCodeDiv.textContent = res.status;
                responseBodyDiv.textContent = formatJSON(text);
            } catch (error) {
                responseCodeDiv.textContent = 'Error';
                responseBodyDiv.textContent = error.message;
            }
        }


        async function getFeature() {
            const name = document.getElementById('GET_featureName').value.trim();
            const address = document.getElementById('GET_featureAddress').value.trim();

            const responseCodeDiv = document.getElementById('GET_featureResponseCode');
            const responseBodyDiv = document.getElementById('GET_featureResponseBody');
            if (!name) {
                alert("Feature name is required.");
                return;
            }
            const apiBase = window.location.origin;
            const url = `${apiBase}/feature/${name}${address ? `/${address}` : ''}`;
            try {
                const res = await fetch(url);
                const text = await res.text();
                responseCodeDiv.textContent = res.status;
                responseBodyDiv.textContent = formatJSON(text);
            } catch (error) {
                responseCodeDiv.textContent = 'Error';
                responseBodyDiv.textContent = error.message;
            }
        }
        // --------------------------------------------------------------------------
        // Transformation
        // --------------------------------------------------------------------------
        async function getTransformation() {
            const name = document.getElementById('GET_transformationName').value.trim();
            const address = document.getElementById('GET_transformationAddress').value.trim();

            const responseCodeDiv = document.getElementById('GET_transformationResponseCode');
            const responseBodyDiv = document.getElementById('GET_transformationResponseBody');

            if (!name) {
                alert("Transformation name is required.");
                return;
            }

            const apiBase = window.location.origin;
            const url = `${apiBase}/transformation/${name}${address ? `/${address}` : ''}`;
            try {
                const res = await fetch(url);
                const text = await res.text();
                responseCodeDiv.textContent = res.status;
                responseBodyDiv.textContent = formatJSON(text);
            } catch (error) {
                responseCodeDiv.textContent = 'Error';
                responseBodyDiv.textContent = error.message;
            }
        }

        function updateTransformationPreview() {
            const name = document.getElementById('POST_transformationName').value.trim();
            const sol_src = document.getElementById('POST_transformationCode').value.trim();
            const obj = { name, sol_src };
            document.getElementById('POST_transformationRequestBody').textContent = JSON.stringify(obj, null, 2);
        }

        async function sendStructuredTransformation() {
            const name = document.getElementById('POST_transformationName').value.trim();
            const sol_src = document.getElementById('POST_transformationCode').value.trim();

            const responseCodeDiv = document.getElementById('POST_transformationResponseCode');
            const responseBodyDiv = document.getElementById('POST_transformationResponseBody');
            
            if (!name) {
                alert("Transformation name is required.");
                return;
            }

            try {
                const apiBase = window.location.origin;
                const res = await requestWithRefresh(`${apiBase}/transformation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ name, sol_src }),
                    credentials: 'include'
                });
                const text = await res.text();
                responseCodeDiv.textContent = res.status;
                responseBodyDiv.textContent = formatJSON(text);
            } catch (error) {
                responseCodeDiv.textContent = 'Error';
                responseBodyDiv.textContent = error.message;
            }
        }

        // --------------------------------------------------------------------------
        // Version
        // --------------------------------------------------------------------------
        async function fetchVersionInfo() {
            const versionDiv = document.getElementById('versionInfo');
            try {
                const res = await fetch(`${window.location.origin}/version`);
                const data = await res.json();
                versionDiv.textContent = `Version ${data.version} (Built: ${data.build_timestamp})`;
            } catch (err) {
                versionDiv.textContent = "‚ö†Ô∏è Failed to fetch version info";
                console.error("Version fetch failed:", err);
            }
        }

        // Fetch version info on page load
        fetchVersionInfo();

        // --------------------------------------------------------------------------
        // Login
        // --------------------------------------------------------------------------
        // MetaMask login functionality
        const loginButton = document.getElementById('login');
        const loginStatusDiv = document.getElementById('loginStatus');

        async function loginWithMetaMask() {

            if (typeof window.ethereum === 'undefined') {
                alert("MetaMask is not installed!");
                return;
            }
            try {
                const [address] = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const apiBase = window.location.origin;
                const nonceRes = await fetch(`${apiBase}/nonce/` + address);
                const { nonce } = await nonceRes.json();

                const message = `Login nonce: ${nonce}`;
                const signature = await window.ethereum.request({
                    method: 'personal_sign',
                    params: [message, address],
                });

                const authRes = await fetch(`${apiBase}/auth`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address, signature, message }),
                });

                const result = await authRes.json();

                if (result.success) {
                    loginStatusDiv.innerHTML = `<p style="color: green;">‚úÖ Authenticated as <strong>${address}</strong></p>`;
                }
                else {
                    loginStatusDiv.innerHTML = `<p style="color: red;">‚ùå Authentication failed</p>`;
                }
            } catch (err) {
                console.error(err);
                loginStatusDiv.innerHTML = `<p style="color: red;">‚ö†Ô∏è Error: ${err.message}</p>`;
            }
        }
        loginButton.onclick = loginWithMetaMask;

        // --------------------------------------------------------------------------
        // Utils
        // --------------------------------------------------------------------------
        // Function to format the JSON response nicely
        function formatJSON(text) {
            try {
                const json = JSON.parse(text);
                return JSON.stringify(json, null, 2); // Pretty-print with 2 spaces
            } catch (e) {
                return text; // If not valid JSON, return as it is
            }
        }

        function hexToRgba(hex, alpha = 1.0) {
            const r = parseInt(hex.substr(1, 2), 16);
            const g = parseInt(hex.substr(3, 2), 16);
            const b = parseInt(hex.substr(5, 2), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        async function requestWithRefresh(url, options = {}) {
            // always include cookies
            options.credentials = 'include';

            // first attempt
            let res = await fetch(url, options);
            if (res.status !== 401) {
                return res;
            }

            // 401 ‚Üí try to refresh
            const apiBase = window.location.origin;
            const refreshRes = await fetch(`${apiBase}/refresh`, {
                method: 'POST',
                credentials: 'include'
            });
            if (refreshRes.ok) {
                // retry original request once
                res = await fetch(url, options);
            }
            return res;
        }

    </script>

</body>

</html>